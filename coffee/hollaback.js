// Generated by CoffeeScript 2.3.2
(function() {
  var $, Vex, hollaback, now, resolution;

  resolution = 16;

  $ = window.$;

  Vex = window.Vex;

  now = function() {
    return Date.now();
  };

  Array.prototype.last = function() {
    return this[this.length - 1];
  };

  Number.prototype.msb = function() {
    var i;
    i = 0;
    while ((1 << i) <= this) {
      ++i;
    }
    return i - 1;
  };

  hollaback = window.angular.module("hollaback", []);

  hollaback.controller("HollabackCtrl", function($scope) {
    $scope._init = function() {
      var Emit, Fill, artist, header, notes, renderer, transValue, vextab;
      // time signature
      this.beatsPerBar = 4;
      this.beatValue = 4;
      // tempo
      this.bpm = 96;
      this.taps = {
        diffs: [],
        stamps: []
      };
      // rhythm
      this.sampleRate = 78;
      this.sampleCount = 0;
      this.curBar = null;
      this.bars = [];
      // transcription
      this.ResetBpm = function() {
        this.taps.diffs = [];
        return this.taps.stamps = [];
      };
      this.TapBpm = function() {
        var stamp;
        stamp = now();
        if (this.taps.stamps.length) {
          this.taps.diffs.push(stamp - this.taps.stamps.last());
        }
        this.taps.stamps.push(stamp);
        if (this.taps.diffs.length > 1) {
          this.bpm = Math.round(60000 * this.taps.diffs.length / this.taps.diffs.reduce(function(x, item) {
            return x + item;
          }, 0));
          return this.sampleRate = Math.round(1000 / (this.bpm * resolution / this.beatValue / 60));
        }
      };
      this.TapRhythm = function() {
        var timeout;
        if (this.curBar == null) {
          this.curBar = [];
          (timeout = () => {
            this.sampleCount++;
            if (this.sampleCount === resolution) {
              this.sampleCount = 0;
              this.bars.push(this.curBar);
              this.finishedNotes.push(this.AnalyzeBar(this.curBar));
              this.curBar = [];
            }
            setTimeout(timeout, this.sampleRate);
            return this.$apply();
          })();
        }
        return this.curBar.push(this.sampleCount);
      };
      notes = [];
      transValue = 0;
      Emit = function(len, rest = false) {
        if (len === transValue) {
          notes.push("-");
        } else {
          notes.push("/4");
          if (len === 0) {
            return;
          }
          notes.push(":" + len);
        }
        transValue = len;
        return notes.push("X");
      };
      Fill = function(start, end, rest = false) {
        var diff, log2, sigil;
        diff = end - start;
        if (diff === 0) {
          return [];
        }
        sigil = rest ? "r" : "";
        log2 = Math.pow(2, diff.msb());
        if (diff === log2) {
          return [resolution / log2 + sigil];
        }
        if (start % log2 !== 0) {
          log2 /= 2;
        }
        return [resolution / log2 + sigil].concat(Fill(start + log2, end, true));
      };
      this.finishedNotes = [];
      this.AnalyzeBar = function(bar) {
        var note, remaining, rhythm;
        rhythm = [];
        remaining = resolution;
        note = 0;
        while (bar.length) {
          note = bar.pop();
          rhythm = Fill(note, remaining).concat(rhythm);
          remaining = note;
        }
        if (note !== 0) {
          rhythm = Fill(0, note, true).concat(rhythm);
        }
        this.RenderVex(rhythm);
        return $("#error").text(rhythm.join(" "));
      };
      renderer = new Vex.Flow.Renderer($('#engraving')[0], Vex.Flow.Renderer.Backends.CANVAS);
      artist = new Vex.Flow.Artist(10, 10, 600, {
        scale: 0.8
      });
      vextab = new Vex.Flow.VexTab(artist);
      header = "";
      return this.RenderVex = (rhythm) => {
        var code, duration, e, j, last, len1, note, rest;
        code = "\ntabstave clef=percussion notation=true tablature=false\nnotes ";
        last = -1;
        for (j = 0, len1 = rhythm.length; j < len1; j++) {
          note = rhythm[j];
          duration = note;
          rest = false;
          if (note.substr(-1) === "r") {
            duration = note.substr(0, note.length - 1);
            rest = true;
          }
          if (duration !== last) {
            if (last !== -1) {
              code += "/4";
            }
            code += " :" + duration + " ";
            last = duration;
          } else {
            code += "-";
          }
          if (rest) {
            code += "X";
          } else {
            code += "B";
          }
        }
        code += " /4 ";
        header += code;
        try {
          vextab.reset();
          artist.reset();
          vextab.parse(header);
          artist.render(renderer);
          return $("#error").text(code);
        } catch (error) {
          e = error;
          return $("#error").text(e);
        }
      };
    };
    return $scope._init();
  });

}).call(this);
